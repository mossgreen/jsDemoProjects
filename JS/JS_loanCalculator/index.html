<!DOCTYPE html>
<html>
<head>
	<title>Javascript Loan Calculator</title>
	<!-- 这是一个CSS 样式表：定义了程序输出的样式 -->
	<style>
		.output{
			font-weight: blod; //计算结果定义为粗体
		}
		#payment{
			text-decoration: underline; /*定义 id="payment" 的元素样式*/
		}
		#graph{
			boder:solid black 1px; /*图标有一个 1px 的边框*/
		}
		th, td{
			vertical-align: top; /*表格单元格对齐方式为顶端对齐*/
		}

	</style>
</head>

<!-- 这是一个HTML表格，其中包含 input 元素可以用来输入数据。
程序将在 span 元素中显示计算结果，这些元素都具有类似 interest 和 years 的id
这些id 将在表格下面的JS 代码中用到。 
我们注意到， 有一些input 元素定义了 onchange 或onclick 事件
以便用户在输入数据或者点击inputs 时执行制定的JS代码。 -->
<body>
	<table>
		<tr>
			<th>Enter Loan Date:</th>
			<td></td>
			<th>Loan Balance, Cumulative Equity, and Interest Payments</th>
		</tr>
		<tr>
			<td>Amount of the loan ($):</td>
			<td><input id="amount" onchange="calculate();"> </td>
			<td rowspan=8><canvas id="graph" width="400" height="250"></canvas></td>
		</tr>
		<tr>
			<td>Annual interest(%):</td>
			<td><input id="apr" onchange="calculate();"></input></td>
		</tr>
		<tr>
			<td>Repayment period(years):</td>
			<td><input id="years" onchange="calculate();"></input></td>
		</tr>
		<tr>
			<td>Zipcode (to find lenders):</td>
			<td><input id="zipcode" onchange="calculate();"></input></td>
		</tr>
		<tr>
			<td>Approximate Payments:</td>
			<td><button onclick="calculate();">Calculate</button></td>
		</tr>
		<tr>
			<td>Monthly payment:</td>
			<td>$<span class="output" id="payment"></span></td>
		</tr>
		<tr>
			<td>Total payment:</td>
			<td>$<span class="output" id="total"></span></td>
		</tr>
		<tr>
			<td>Total interest:</td>
			<td>$<span class="output" id="totalinterest"></span></td>
		</tr>
		<tr>
			<th>Sponsors:</th>
			<td colspan=2>
				Apply for your loan with one of these fine lenders:
				<div id="lenders"></div>
			</td>
		</tr>
	</table>

	<script>
		"use strict";  
		// 如果浏览器支持的话，将开启ECMAScript5 严格模式
		// calculate（）函数在HTML中绑定了事件处理，这个函数从 input 元素中读取数据，
		// 计算贷款赔付信息，并将结果显示在 span 元素中。
		// 同时，这里还保存了用户信息，展示了放贷人链接并绘制了图表。
		function calculate(){
			// 查找文档中用于输入输出的元素
			var amount = document.getElementById("amount");
			var apr = document.getElementById("apr");
			var years = document.getElementById("years");
			var zipcode = document.getElementById("zipcode");
			var payment = document.getElementById("payment");
			var total = document.getElementById("total");
			var totalinterest = document.getElementById("totalinterest");

			// 假设所有的输入都是合法的，将从input 元素中获取输入数据
			// 将百分比格式转换为小数格式，并从年利率转换为月利略
			// 将年度赔付转换为月度赔付
			var principal = parseFloat(amount.value);
			var interest = parseFloat(apr.value)/100/12;
			var payments = parseFloat(years.value)*12;


			// 计算月度赔付的数据
			var x = Math.pow(1+interest, payments); //Math.pow（）进行幂次运算
			var monthly = (principal*x*interest)/(x-1);


			// 如果结果没有超过JS能表示的数字范围，且用户的输入也正确，展示便合法
			if(isFinite(monthly)){
				// 将数据填充至输出字段的位置，四舍五入到小数点后两位
				payment.innerHTML = monthly.toFixed(2);
				total.innerHTML = (monthly*payments).toFixed(2);
				totalinterest.innerHTML = ((monthly*payments) - principal).toFixed(2);

				// 将用户数据保存下来，在下次访问时能取得数据
				save(amount.value, apr.value, years.value, zipcode.value);

				// 找到并展示本地放贷人，但是忽略网络错误
				try{
					getLenders(amount.value, apr.value, years.value, zipcode.value);
				}
				catch(e){} //忽略异常

				// 用图表展示贷款余额，利息和资产收益
				chart(principal, interest, monthly, payments);
			}else{

				// 计算结果不是数字或者是无穷大，意味着输入是非法的活着不完整。清空数据
				payment.innerHTML = "";
				total.innerHTML = "";
				totalinterest.innerHTML = "";
				chart(); // 不传参数就是清除图表
			}
		}


		// 将用户的输入保存至localStorage 对象的属性中
		// 这些属性在再次访问时还会继续保持在原位置
		// 如果你在浏览器中按照 file：URL 的方式直接打开本地文件，
		// 则无法在某些浏览器中使用存储功能过，如firefox
		// 而通过http 打开文件时可行的。
		function save(amout, apr, years, zipcode){
			if(window.localStorage){ // 只有在浏览器支持的时候才运行这里的代码
				localStorage.loan_amount=amount;
				localStorage.loan_apr = apr;
				localStorage.loan_years = years;
				localStorage.loan_zipcode = zipcode;
			}
		}

		// 在文档首次加载时，将会尝试还原输入字段
		window.onload = function(){
			// 如果浏览器支持本地存储，并且上次保存的值是存在的
			if(window.localStorage && localStorage.loan_amount){
				document.getElementById("amount").value = localStorage.loan_amount;
				document.getElementById("apr").value = localStorage.loan_apr;
				document.getElementById("years").value = localStorage.loan_years;
				document.getElementById("zipcode").value = localStorage.loan_zipcode;
			}
		};


		// 将用户的输入发送至服务器脚本上（理论上），将返回一个本地放贷人的链接列表，
		// 在这个例子中并没有实现这种查找放贷人的服务，
		// 但是如果该服务存在，该函数会使用它
		function getLenders(amount, apr, years, zipcode){
			// 如果浏览器不支持XMLHttpRequest对象，退出
			if(!window.XMLHttpRequest) return;

			// 找到要显示放贷人列表的元素，如果没有则返回
			var ad = document.getElementById("lenders");
			if(!ad) return;

			// 将用户的输入数据进行URL编码，并作为查询参数附加在URL里
			var url = "getLenders.php" + "?amt=" + endodeURLComponent(amount)+ "&apr=" + endodeURLComponent(apr) + "&yrs=" + endodeURLComponent(years) + "&zip=" + endodeURLComponent(zipcode);

			// 通过XMLHttpRequest对象来提取返回数据
			var req = new XMLHttpRequest();
			req.open("GET", url);
			req.send(null);

			// 在返回数据前，注册一个事件处理函数，
			// 这个函数将会在服务器响应返回至客户端的时候调用
			// 这种异步程序模型在客户端JS中很常见
			req.onreadystatechange = function(){
				if(req.readyState == 4 && req.status == 200){
					// 此时，我们得到了一个合法且完整的HTTP 响应
					var response = req.responseText; //HTTP 响应是以字符串形式呈现的
					var lenders = JSON.parse(response); // 将其解析为JS 数组

					// 将数组中的放贷人对象转换为HTML 字符串形式
					var list = "";
					for(var i = 0; i<lenders.length; i++){
						list += "<li><a href='"+lenders[i].url + "'>" + lenders[i].name + "</a>";
					}

					// 将数据在 HTTP元素中呈现出来
					ad.innerHTML = "<url>" + list + "</url>";
				}
			}
		}


		// 在 HTML canvas元素中用图表展示月度贷款余额、利息和资产收益
		// 如果不传入参数的话，则清空之前的图表数据
		function chart(principal, interest, monthly, payments){
			var graph = document.getElementById("graph"); //得到canvas 标签
			graph.width = graph.width; // 清除并重置画布的方法，很巧妙。。。

			// 如果不传入参数，或者浏览器不支持画布，则直接返回
			if(arguments.length == 0 || !graph.getContext) return;

			// 获得画布元素的 context 对象，这个对象定义了一组绘画API
			var g = graph.getContext("2d"); //所有的绘画操作都将基于这个对象
			// 获得画布的大小
			var width = graph.width, height = graph.height;


			// 函数作用是将付款数字和美元数据转换为像素
			function paymentTox(n){
				return n*width/payments;
			}

			function amountToY(a){
				return height - (a*height/(monthly*payments*1.05));
			}

			// 付款数据是一条从（0，0） 到（payments， monthly＊payments） 的直线
			g.moveTo(paymentTox(0), amountToY(0));
			g.lineTo(paymentTox(payments),amountToY(monthly*payments));
			g.lineTo(paymentTox(payments), amountToY(0));
			g.closePath();
			g.fillStyle = "#f88"; //亮红色
			g.fill();
			g.font = "bold 12px sans-serif";
			g.fillText("Total Interest Payments", 20,20);

			// 很多资产数据并不是线性的，很难反映至图表中
			var equity = 0;
			g.beginPath();
			g.moveTo(paymentTox(0), amountToY(0));
			for(var p = 1; p<= payments; p++){
				// 计算出每一笔赔付的利息
				var thisMonthsInterest = (principal - equity)*interest;
				equity += (monthly - thisMonthsInterest);
				g.lineTo(paymentTox(p), amountToY(equity));
			}
			g.lineTo(paymentTox(payments), amountToY(0));
			g.closePath;
			g.fillStyle = "green";
			g.fill();
			g.fillText("Total Equity", 20, 35);

			// 再次循环，余额数据显示为黑色粗线条
			var bal = principal;
			g.moveTo(paymentTox(0), amountToY(bal));
			for(var p = 1; p<payments; p++){
				var thisMonthsInterest = bal*interest;
				bal -= (monthly - thisMonthsInterest); //得到资产额
				g.lineTo(paymentTox(p), amountToY(bal));
			}

			g.lineWidth = 3; //线条加粗
			g.stroke();
			g.fillStyle = "black";
			g.fillText("Loan balance", 20, 50);

			// 将年度数据在X轴做标记，文字居中， Y坐标设为0
			g.textAlign = "center";
			var y = amountToY(0);
			// 遍历年
			for(var year = 1; year*12<= payments; year++){
				var x = paymentTox(year *12);
				g.fillRect(x - 0.5, y-3, 1,3);
				if(year == 1) g.fillText("Year", x, y-5);
				if(year%5 == 0 && year*12 != payments) g.fillText(String(year), x, y-5);
			}

			// 将赔付数额标记在右边界
			g.textAlign = "right"; //文字右对齐
			g.textBaseline = "middle"; //文字垂直居中
			var ticks = [monthly*payments, principal];
			var rightEdge = paymentTox(payments);
			for(var i = 0; i<ticks.length; i++){
				var y = amountToY(ticks[i]);
				g.fillRect(rightEdge - 3; y-0.5, 3, 1);
				g.fillText(String(ticks[i].toFixed(0)), rightEdge -5, y);
			}

		}
	</script>
</body>
</html>































